{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Reciprocal n-body Collision Avoidance","text":""},{"location":"#importer-les-packages","title":"Importer les Packages","text":"<p>Packages</p> <ul> <li> <p>NumPy : NumPy est une biblioth\u00e8que Python populaire pour le calcul scientifique qui fournit des structures de donn\u00e9es pour la repr\u00e9sentation de tableaux multidimensionnels et des fonctions pour manipuler ces tableaux.</p> </li> <li> <p>Matplotlib : Matplotlib est une biblioth\u00e8que en Python utilis\u00e9e pour tracer des graphiques et des visualisations.</p> </li> <li> <p>heapq : heapq est un module Python qui impl\u00e9mente les algorithmes d\u2019heaps ou de tas pour des structures de donn\u00e9es.</p> </li> <li> <p>math : Le module math en Python fournit des fonctions math\u00e9matiques courantes, telles que les fonctions trigonom\u00e9triques, exponentielles, logarithmiques, etc.</p> </li> <li> <p>CVXOPT : CVXOPT est une biblioth\u00e8que open source Python pour l\u2019optimisation convexe. Elle est utilis\u00e9e pour r\u00e9soudre des probl\u00e8mes d\u2019optimisation convexe tels que la programmation lin\u00e9aire, la programmation quadratique, la programmation semi-d\u00e9finie, la programmation convexe et autres. Elle fournit des solveurs rapides et pr\u00e9cis pour les probl\u00e8mes d\u2019optimisation convexe, y compris des interfaces pour les solvers externes.</p> </li> <li> <p>random : The random module in Python provides a suite of functions for generating random numbers.</p> </li> <li> <p>time : Le module time est un module Python qui fournit diverses fonctions permettant de manipuler le temps.</p> </li> <li> <p>cv2 : cv2 is a library for computer vision and image processing. It is a Python wrapper for OpenCV (Open Source Computer Vision), which is a C++ library that includes numerous computer vision algorithms.</p> </li> <li> <p>IPython : La biblioth\u00e8que IPython fournit un certain nombre d\u2019outils pour faciliter le d\u00e9veloppement et l\u2019analyse de donn\u00e9es en Python.</p> </li> <li> <p>tqdm : tqdm is a Python package that provides a progress bar visualization for iterative tasks, making it easy to see how far along a task is and how much longer it is expected to take.</p> </li> </ul> <pre><code>import numpy\nfrom numpy.linalg import norm\nfrom numpy import dot,array\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle, Circle\nimport matplotlib.patches as patches\nfrom pylab import show,imshow\nimport heapq\nfrom math import *\nimport cvxopt\nfrom cvxopt import matrix,solvers\nimport random\nimport time\nimport os\nimport matplotlib.animation as animation\nimport cv2\nfrom IPython import display\nfrom tqdm import tqdm\n</code></pre>"},{"location":"#initialiser-la-geometrie","title":"Initialiser la g\u00e9om\u00e9trie","text":"<p>draw</p> <p>On commence par d\u00e9finir la fonction <code>draw</code> qui prend plusieurs arguments en entr\u00e9e et qui trace une sc\u00e8ne avec des agents et des obstacles.</p> <p>Les arguments en entr\u00e9e sont:</p> <p>Ex : une liste des sorties de la sc\u00e8ne</p> <p>Obs : une liste des obstacles rectangulaires</p> <p>Obs_cir : une liste des obstacles circulaires</p> <p>scene : une paire (L, l) qui repr\u00e9sente les dimensions de la sc\u00e8ne</p> <p>agents : une liste d\u2019agents, o\u00f9 chaque agent est repr\u00e9sent\u00e9 par sa position, sa taille et sa couleur</p> <p>t : temps de simulation</p> <p>savepath : le chemin pour enregistrer la figure g\u00e9n\u00e9r\u00e9e</p> <p>play : un bool\u00e9en qui sp\u00e9cifie si l\u2019animation doit \u00eatre affich\u00e9e ou non</p> <p>La fonction commence par cr\u00e9er une figure et un axe avec une taille d\u00e9termin\u00e9e par la dimension de la sc\u00e8ne. Ensuite, elle dessine les obstacles, les sorties et les agents sur la figure. Les obstacles rectangulaires sont repr\u00e9sent\u00e9s par des rectangles noirs, les obstacles circulaires par des cercles noirs, les sorties par des rectangles orange et les agents par des cercles de couleur.</p> <p>Enfin, la fonction sauvegarde la figure \u00e0 l\u2019emplacement sp\u00e9cifi\u00e9 par \u201csavepath\u201d. Si \u201cplay\u201d est faux, la figure est ferm\u00e9e.</p> <pre><code>def draw(Ex, Obs, Obs_cir, scene, agents, t, savepath, play = False):\nL , l = scene\nratio = l/L\nc = 10\nfig, ax = plt.subplots(figsize=(c/ratio,c))\ntitle = ax.text(0.5, 1.05, \"Temps de simulation : %s s \\n Nombre des agents : %s\" %(t,len(agents)), \ntransform=ax.transAxes, ha=\"center\", size=20)\n#Draw the environment\nplt.plot([0, L], [0, 0], 'white')\nplt.plot([L, L], [0, l], 'white')\nplt.plot([L, 0], [l,l], 'white')\nplt.plot([0,0], [l,0], 'white')\n#Draw Obstacle\nfor obs in Obs:\nrect = Rectangle(obs.position, obs.width, obs.height)\nrect.set_color('black')\nax.add_patch(rect)\n#Draw Obstacle Cir\nfor obs in Obs_cir:\ncircle = Circle(obs.position, obs.rayon)\ncircle.set_color('black')\nax.add_patch(circle)\n#Draw exits\nfor e in Ex:\nrect = Rectangle(e.position, e.width, e.height)\nrect.set_color('orange')\nax.add_patch(rect)\n#Draw agents\nfor agent in agents:\nx,y = agent.position\ncircle = Circle((x,y), agent.size)\ncircle.set_color(agent.color)\nax.add_patch(circle)\nplt.xticks(fontsize=20)\nplt.yticks(fontsize=20)\nfig.savefig(savepath)\nif not play:\nplt.close()\n</code></pre> <p>record_video</p> <p>La fonction appel\u00e9e <code>record_video</code> prend un argument optionnel speed (dont la valeur par d\u00e9faut est 25). Le but de cette fonction est de cr\u00e9er une vid\u00e9o \u00e0 partir d\u2019une s\u00e9quence d\u2019images sauvegard\u00e9es dans un r\u00e9pertoire, et de sauvegarder le fichier vid\u00e9o r\u00e9sultant dans le r\u00e9pertoire de travail actuel. Les arguments pass\u00e9s \u00e0 cette fonction sont les suivants :</p> <p>speed : une valeur enti\u00e8re repr\u00e9sentant le nombre d\u2019images par seconde de la vid\u00e9o r\u00e9sultante (c\u2019est-\u00e0-dire le taux de rafra\u00eechissement de la vid\u00e9o).</p> <p>La fonction commence par imprimer un message indiquant qu\u2019elle commence l\u2019enregistrement de la vid\u00e9o. Ensuite, elle lit la premi\u00e8re image de la s\u00e9quence d\u2019images pour d\u00e9terminer les dimensions de la vid\u00e9o.</p> <p>Elle cr\u00e9e ensuite un objet VideoWriter en utilisant la m\u00e9thode cv2.VideoWriter d\u2019OpenCV, en sp\u00e9cifiant le nom du fichier de sortie, le codec vid\u00e9o (dans ce cas XVID), le taux de rafra\u00eechissement et les dimensions de la vid\u00e9o (bas\u00e9es sur les dimensions de la premi\u00e8re image).</p> <p>Ensuite, elle boucle sur les images restantes de la s\u00e9quence et ajoute chacune \u00e0 la vid\u00e9o \u00e0 l\u2019aide de la m\u00e9thode video.write(). Les images sont lues en utilisant la m\u00e9thode cv2.imread() d\u2019OpenCV, qui lit une image \u00e0 partir d\u2019un chemin de fichier sp\u00e9cifi\u00e9.</p> <p>Enfin, la fonction nettoie toutes les fen\u00eatres qui ont pu \u00eatre cr\u00e9\u00e9es pendant le processus et lib\u00e8re l\u2019objet vid\u00e9o. Elle affiche un message indiquant que la vid\u00e9o a \u00e9t\u00e9 sauvegard\u00e9e.</p> <pre><code>def record_video(speed = 25):\nprint('Recording video ...')\nframe = cv2.imread('DossierImages/simulation' + str(10) + '.jpg')\nheight, width, layers = frame.shape\nfourcc = cv2.VideoWriter_fourcc(*'XVID')\nvideo = cv2.VideoWriter('video.avi', fourcc, speed, (width,height))\nfor k in range(N_iter):\nvideo.write(cv2.imread('DossierImages/simulation' + str(k+1) + '.jpg'))\ncv2.destroyAllWindows()\nvideo.release()\nprint('Video saved.')\n</code></pre> <p>generate_indiv</p> <p>La fonction <code>generate_indiv(N)</code> cr\u00e9e une liste de N agents en v\u00e9rifiant qu\u2019ils ne se chevauchent pas et ne traversent pas les obstacles. Voici les \u00e9tapes principales :</p> <ul> <li> <p> La fonction d\u00e9finit la taille de la sc\u00e8ne, ainsi que des variables pour la distance minimale entre les agents et pour le rayon de chaque agent.</p> </li> <li> <p> La fonction cr\u00e9e une liste vide L qui contiendra les agents, puis elle commence une boucle qui s\u2019arr\u00eatera quand il y aura N agents dans la liste L.</p> </li> <li> <p> \u00c0 chaque it\u00e9ration de la boucle, la fonction g\u00e9n\u00e8re une position al\u00e9atoire pour un nouvel agent en utilisant des fonctions al\u00e9atoires et l\u2019ajoute \u00e0 une liste temporaire q, qui contient les positions de tous les agents d\u00e9j\u00e0 cr\u00e9\u00e9s, ainsi que les rayons de ces agents, qui sont stock\u00e9s dans la liste R.</p> </li> <li> <p> Ensuite, la fonction v\u00e9rifie s\u2019il y a une collision entre le nouvel agent et les agents d\u00e9j\u00e0 cr\u00e9\u00e9s. Si c\u2019est le cas, la variable choc est d\u00e9finie sur True, ce qui signifie qu\u2019il y a eu une collision et que le nouvel agent ne sera pas ajout\u00e9 \u00e0 la liste L.</p> </li> <li> <p> Ensuite, la fonction v\u00e9rifie si le nouvel agent entre en collision avec un obstacle. Si c\u2019est le cas, la variable choc est d\u00e9finie sur True.</p> </li> <li> <p> Si le nouvel agent ne provoque pas de collision, il est ajout\u00e9 \u00e0 la liste L.</p> </li> <li> <p> Lorsque N agents ont \u00e9t\u00e9 cr\u00e9\u00e9s et ajout\u00e9s \u00e0 la liste L, la fonction retourne cette liste.</p> </li> </ul> <pre><code>def generate_indiv(N):\ndef rand_float_range(start, end):\nreturn random.random() * (end - start) + start\na , b = size_scene\ndst = 0.2\nr = 0.2\nL = list()\nwhile len(L) &lt; N:\nchoc = False\nq = [agent.position for agent in L]\nR = [agent.size for agent in L]\nx = rand_float_range(int(0),int(a))\ny = rand_float_range(int(0),int(b))\nq.append([x,y])\nR.append(r)\nfor j in range(len(q)-1):\nif dist(q[-1], q[j]) - (R[-1]+R[j]) &lt;= dst:\nchoc = True\nbreak\n#chocs obstacle\nfor obstacle in obstacles_cir:\n[a0, b0], rayon = obstacle.position, obstacle.rayon\nif (x-a0)**2 + (y-b0)**2 &lt; (rayon+3)**2 : choc = True\nfor obstacle in obstacles:\n[a0, b0], w, l = obstacle.position, obstacle.width, obstacle.height\na1, b1 = a0 + w , b0 + l\nif (a0&lt;=x&lt;=a1 and b0-r-0.5&lt;=y&lt;=b1+r+0.5) or (b0&lt;=y&lt;=b1 and a0-r-0.5&lt;=x&lt;=a1+r+0.5): choc = True\nelif distance_vecteur_obs([x,y] , r, obstacle)[0] &lt; 0.5: choc = True\nif not choc:\nagent = myAgent((x,y))\nagent.size = r\nL.append(agent)\nreturn L\n</code></pre> <p>maxiMini &amp; plot_directions</p> <p>La premi\u00e8re fonction, nomm\u00e9e <code>maxiMini(FX,FY)</code>, prend en entr\u00e9e deux listes FX et FY, contenant des valeurs de directions. Cette fonction parcourt les deux listes et recherche la valeur maximale et la valeur minimale des directions dans chaque liste. Elle retourne ensuite ces deux valeurs.</p> <p>La deuxi\u00e8me fonction, nomm\u00e9e <code>plot_directions(FX,FY)</code>, prend \u00e9galement en entr\u00e9e deux listes FX et FY. Cette fonction affiche deux graphiques c\u00f4te \u00e0 c\u00f4te : un pour les directions selon X et un pour les directions selon Y. Les directions sont repr\u00e9sent\u00e9es par des couleurs sur chaque graphique, et les couleurs correspondent \u00e0 des valeurs. Les valeurs minimales et maximales sont obtenues en appelant la fonction <code>maxiMini(FX,FY)</code>. Les graphiques sont affich\u00e9s \u00e0 l\u2019aide de la biblioth\u00e8que Matplotlib. Enfin, cette fonction retourne les graphiques affich\u00e9s.</p> <p>En r\u00e9sum\u00e9, ces deux fonctions permettent de visualiser les directions de mouvement \u00e0 partir de listes de directions selon X et Y.</p> <pre><code>def maxiMini(FX,FY):\nmaxi = 0\nMini = 0\nfor i in range(n):\nfor j in range(len(FX[0])):\nfx , fy = FX[i][j] , FY[i][j]\nif fx != float('inf') and fx != -float('inf') and fy != float('inf') and fy != -float('inf') and not isnan(fx) and not isnan(fy):\nif fx&gt;maxi :\nmaxi = fx\nif fy&gt;maxi :\nmaxi = fy\nif fx&lt;Mini : \nMini = fx\nif fy&lt;Mini :\nMini = fy\nreturn maxi , Mini\ndef plot_directions(FX,FY):\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15,15))\nZ = [FX, FY]\ntext = ['Directions selon X', 'Directions selon Y']\nmaxi , Mini = maxiMini(FX,FY)\nfor ax, i in zip(axes.flat, range(2)):\nim = ax.imshow(Z[i], interpolation=\"bicubic\", origin=\"upper\", vmin=Mini, vmax=maxi)\nax.title.set_text(text[i])\nfig.subplots_adjust(right=0.8)\ncbar_ax = fig.add_axes([0.85, 0.35, 0.05, 0.3])\nfig.colorbar(im, cax=cbar_ax)\nplt.show()\n</code></pre> <p>Exit</p> <p>Ce code d\u00e9finit une classe <code>Exit</code> qui repr\u00e9sente une sortie. La classe poss\u00e8de un constructeur (init) qui prend en argument une position, une largeur et une hauteur de la sortie. La position est un tuple de deux \u00e9l\u00e9ments repr\u00e9sentant les coordonn\u00e9es (x, y) du coin sup\u00e9rieur gauche de la sortie.</p> <p>Le constructeur initialise les attributs position, width et height de la classe avec les valeurs pass\u00e9es en argument.</p> <pre><code>class Exit:\ndef __init__(self,position,width,height):\nself.position = position\nself.width = width\nself.height = height\n</code></pre> <p>Obstacle</p> <p>La classe <code>Obstacle</code> a pour but de repr\u00e9senter un obstacle dans une simulation. Elle poss\u00e8de trois attributs : position, width et height, qui correspondent respectivement \u00e0 la position de l\u2019obstacle et \u00e0 sa largeur et hauteur.</p> <p>La m\u00e9thode repr de la classe est une m\u00e9thode sp\u00e9ciale qui renvoie une cha\u00eene de caract\u00e8res repr\u00e9sentant l\u2019objet. Dans ce cas pr\u00e9cis, elle renvoie une cha\u00eene de caract\u00e8res contenant la position de l\u2019obstacle ainsi que les coordonn\u00e9es de ses coins (en supposant que la position correspond au coin en bas \u00e0 gauche).</p> <pre><code>class Obstacle():\ndef __init__(self, position,width,height):\nself.position=position\nself.width=width\nself.height=height\ndef __repr__(self):\nreturn 'Obstacle'+'\\n'+'DL:'+str(self.position)+'DR:'+str((self.position[0]+self.width,self.position[1]))+'UR:'+str((self.position[0]+self.width,self.position[1]+self.height))+'UL:'+str((self.position[0]+self.width,self.position[1]))\n</code></pre> <p>Obstacle_Cir</p> <p>Ce code d\u00e9finit une classe <code>Obstacle_Cir</code> qui repr\u00e9sente un obstacle circulaire.</p> <p>La classe a un constructeur `init qui prend deux param\u00e8tres, position et rayon, qui sont utilis\u00e9s pour initialiser les attributs de l\u2019objet. L\u2019attribut position est un tuple qui repr\u00e9sente la position du centre de l\u2019obstacle sur l\u2019espace de simulation et l\u2019attribut rayon est un nombre flottant qui repr\u00e9sente le rayon de l\u2019obstacle.</p> <pre><code>class Obstacle_Cir():\ndef __init__(self, position,rayon):\nself.position=position\nself.rayon=rayon\n</code></pre>"},{"location":"#fast-marching","title":"Fast Marching","text":"<p>PriorityQueue</p> <p>Cette classe est une impl\u00e9mentation d\u2019une file de priorit\u00e9 (ou heap) en utilisant la biblioth\u00e8que heapq.</p> <p>init(self) : Constructeur de la classe qui initialise la file de priorit\u00e9 et un index pour suivre l\u2019\u00e9l\u00e9ment courant.</p> <p>pop(self) : Cette m\u00e9thode supprime et renvoie l\u2019\u00e9l\u00e9ment le plus petit de la file de priorit\u00e9.</p> <p>remove(self, nodeId) : Cette m\u00e9thode prend un noeud (identifi\u00e9 par nodeId) en entr\u00e9e et supprime cet \u00e9l\u00e9ment de la file de priorit\u00e9.</p> <p>iter(self) : Cette m\u00e9thode renvoie l\u2019it\u00e9rateur sur l\u2019instance de la file de priorit\u00e9.</p> <p>str(self) : Cette m\u00e9thode renvoie une repr\u00e9sentation sous forme de cha\u00eene de la file de priorit\u00e9.</p> <p>append(self, node) : Cette m\u00e9thode ajoute un \u00e9l\u00e9ment dans la file de priorit\u00e9.</p> <p>contains(self, key) : Cette m\u00e9thode renvoie True si la cl\u00e9 est pr\u00e9sente dans la file de priorit\u00e9, False sinon.</p> <p>eq(self, other) : Cette m\u00e9thode v\u00e9rifie si deux files de priorit\u00e9 sont \u00e9gales.</p> <p>getitem(self, nodeId) : Cette m\u00e9thode renvoie l\u2019\u00e9l\u00e9ment correspondant \u00e0 l\u2019ID du n\u0153ud donn\u00e9.</p> <p>clear(self) : Cette m\u00e9thode supprime tous les \u00e9l\u00e9ments de la file de priorit\u00e9.</p> <p>len(self) : Cette m\u00e9thode renvoie la longueur de la file de priorit\u00e9.</p> <p>next = next : Cette m\u00e9thode est utilis\u00e9e pour rendre la file de priorit\u00e9 iterable.</p> <pre><code>class PriorityQueue():\ndef __init__(self):\nself.queue = []\nself.current = 0\ndef pop(self):\nreturn heapq.heappop(self.queue)\ndef remove(self, nodeId):\nfor i in range(len(self.queue)):\nif self.queue[i][1]==nodeId:\nself.queue.pop(i)\nbreak;\ndef __iter__(self):\nreturn self\ndef __str__(self):\nreturn 'PQ:[%s]'%(', '.join([str(i) for i in self.queue]))\ndef append(self, node):\nheapq.heappush(self.queue,node)\ndef __contains__(self, key):\nself.current = 0\nreturn key in [n for _,n in self.queue]\ndef __eq__(self, other):\nself.curent = 0\nreturn self == other\ndef __getitem__(self, nodeId):\nfor element in self.queue:\nif element[1]==nodeId:\nreturn element\nreturn None\ndef clear(self):\nself.queue = []\ndef __len__(self):\nreturn len(self.queue)\n__next__ = next\n</code></pre> <p>GridGraph</p> <p>Ce code d\u00e9finit une classe <code>GridGraph</code> qui repr\u00e9sente une grille. Cette grille est utilis\u00e9e pour simuler un environnement dans lequel une ou plusieurs entit\u00e9s se d\u00e9placent, en utilisant un algorithme de calcul de chemin pour d\u00e9terminer le chemin optimal entre deux points.</p> <p>La classe est initialis\u00e9e avec deux param\u00e8tres, size_scene qui est un tuple repr\u00e9sentant la taille de la sc\u00e8ne (la grille) en unit\u00e9s arbitraires, et precision qui d\u00e9termine le nombre de subdivisions dans la grille. La pr\u00e9cision est utilis\u00e9e pour d\u00e9finir la taille de chaque case dans la grille.</p> <p>La grille est mod\u00e9lis\u00e9e par deux matrices, indicator_map et distances. indicator_map est initialis\u00e9e avec des valeurs de 1 pour chaque case de la grille, et sera modifi\u00e9e plus tard pour inclure des obstacles et des sorties. distances est initialis\u00e9e avec des valeurs inf pour chaque case de la grille.</p> <p>La m\u00e9thode get_neighbours est utilis\u00e9e pour renvoyer les voisins d\u2019un n\u0153ud donn\u00e9, repr\u00e9sent\u00e9 par un tuple d\u2019entiers (x, y) indiquant les coordonn\u00e9es du n\u0153ud sur la grille.</p> <p>La m\u00e9thode to_node est utilis\u00e9e pour convertir des coordonn\u00e9es r\u00e9elles en coordonn\u00e9es de n\u0153uds sur la grille.</p> <p>La m\u00e9thode prepare_graph_for_fast_marching est utilis\u00e9e pour modifier indicator_map en y ajoutant des obstacles et des sorties, afin de pr\u00e9parer la grille pour l\u2019algorithme de calcul de chemin. Les obstacles sont d\u00e9finis comme des rectangles ou des cercles, repr\u00e9sent\u00e9s par des objets Obstacle ou ObstacleCir, et les sorties sont repr\u00e9sent\u00e9es par des objets Exit.</p> <pre><code>class GridGraph:\nglobal OBSTACLE\nglobal EXIT\nOBSTACLE = 0\nEXIT = 2\ndef __init__(self,size_scene,precision):\nself.precision = precision\nself.horizontal_size = int(size_scene[0]*precision)+1\nself.vertical_size = int(size_scene[1]*precision)+1\nself.indicator_map = numpy.ones((self.vertical_size,self.horizontal_size))\nself.distances = numpy.ones((self.vertical_size,self.horizontal_size))*float('inf')\ndef get_neighbours(self,node):\nresult = {};\nif node[1]&lt;self.horizontal_size-1:\nresult['x+1']=(node[0],node[1]+1);\nif node[1]&gt;0:\nresult['x-1']=(node[0],node[1]-1);\nif node[0]&lt;self.vertical_size-1:\nresult['y+1']=(node[0]+1,node[1]);\nif node[0]&gt;0:\nresult['y-1']=(node[0]-1,node[1]);\nreturn result;\ndef to_node(self,coordinates):\nreturn (int(coordinates[1]*self.precision),int(coordinates[0]*self.precision))\ndef prepare_graph_for_fast_marching(self,obstacles, obstacles_cir, exits):\nfor obstacle in obstacles:\ndl = (obstacle.position[0],obstacle.position[1])\nur = (obstacle.position[0]+obstacle.width,obstacle.position[1]+obstacle.height)\nfor x in range(self.to_node(dl)[0]+1,self.to_node(ur)[0]):\nfor y in range(self.to_node(dl)[1]+1,self.to_node(ur)[1]):\nif x&gt;=0 and x&lt;self.indicator_map.shape[0] and y&gt;=0 and y&lt;self.indicator_map.shape[1]:\nself.indicator_map[x,y]=OBSTACLE\nfor obstacle_cir in obstacles_cir:\ndl = (obstacle_cir.position[0] - obstacle_cir.rayon , obstacle_cir.position[1] - obstacle_cir.rayon)\nur = (obstacle_cir.position[0] + obstacle_cir.rayon , obstacle_cir.position[1] + obstacle_cir.rayon)\nfor x in range(self.to_node(dl)[0]+1,self.to_node(ur)[0]):\nfor y in range(self.to_node(dl)[1]+1,self.to_node(ur)[1]):\nif x&gt;=0 and x&lt;self.indicator_map.shape[0] and y&gt;=0 and y&lt;self.indicator_map.shape[1]:\nif (x/self.precision - obstacle_cir.position[1])**2 + (y/self.precision - obstacle_cir.position[0])**2 &lt;= obstacle_cir.rayon**2:\nself.indicator_map[x,y]=OBSTACLE\nfor exit_ in exits:\ndl = (exit_.position[0],exit_.position[1])\nur = (exit_.position[0]+exit_.width,exit_.position[1]+exit_.height)\nfor x in range(self.to_node(dl)[0],self.to_node(ur)[0]+1):\nfor y in range(self.to_node(dl)[1],self.to_node(ur)[1]+1):\nif x&gt;=0 and x&lt;self.indicator_map.shape[0] and y&gt;=0 and y&lt;self.indicator_map.shape[1]:\nself.indicator_map[x,y]=EXIT\n</code></pre> <p>fast_marching_method</p> <p>Le code prend en entr\u00e9e un graphe et un point de d\u00e9part et retourne une carte de distance de tous les n\u0153uds du graphe au point de d\u00e9part.</p> <p>Le code commence par d\u00e9finir une fonction calculus_distance qui prend en entr\u00e9e un n\u0153ud, un graphe et des poids et renvoie la distance de ce n\u0153ud au point de d\u00e9part en utilisant la m\u00e9thode de marche rapide. Cette m\u00e9thode calcule la distance en utilisant la distance aux n\u0153uds voisins pond\u00e9r\u00e9e par des poids qui d\u00e9pendent de la g\u00e9om\u00e9trie du probl\u00e8me.</p> <p>Ensuite, le code initialise une file de priorit\u00e9 frontier, qui contiendra les n\u0153uds \u00e0 explorer, et une liste explored qui contiendra les n\u0153uds d\u00e9j\u00e0 explor\u00e9s. Les poids initiaux des n\u0153uds sont stock\u00e9s dans weights. Les points d\u2019arriv\u00e9e sont trouv\u00e9s dans la carte indicator_map et ajout\u00e9s \u00e0 la file de priorit\u00e9 avec une distance initiale de 0. Les poids des points d\u2019arriv\u00e9e sont \u00e9galement initialis\u00e9s \u00e0 0.</p> <p>La boucle principale commence avec l\u2019extraction d\u2019un n\u0153ud de la file de priorit\u00e9 frontier. La distance \u00e0 ce n\u0153ud est stock\u00e9e dans weights. Les voisins du n\u0153ud sont explor\u00e9s, et si un voisin n\u2019a pas d\u00e9j\u00e0 \u00e9t\u00e9 explor\u00e9 et appartient \u00e0 la grille (indiqu\u00e9 par la carte indicator_map), sa distance au point de d\u00e9part est calcul\u00e9e en utilisant la m\u00e9thode calculus_distance. Si le voisin n\u2019est pas d\u00e9j\u00e0 dans la file de priorit\u00e9, il est ajout\u00e9 avec sa nouvelle distance, sinon, si sa distance calcul\u00e9e est inf\u00e9rieure \u00e0 sa distance actuelle, sa distance et sa priorit\u00e9 dans la file de priorit\u00e9 sont mises \u00e0 jour. Les n\u0153uds explor\u00e9s sont ajout\u00e9s \u00e0 la liste explored.</p> <p>Une fois la file de priorit\u00e9 vid\u00e9e, la carte de distance est stock\u00e9e dans la variable distances de l\u2019objet graphe et renvoy\u00e9e.</p> <pre><code>def fast_marching_method(graph,start):\ndef calculus_distance(node,graph,weights):\nneighbours = graph.get_neighbours(node);\nif 'y-1' in neighbours :\nif 'y+1' in neighbours:\nx1 = min(weights[neighbours['y-1']],weights[neighbours['y+1']]);\nelse :\nx1 = weights[neighbours['y-1']];\nelse :\nif 'y+1' in neighbours:\nx1 = weights[neighbours['y+1']];\nif 'x-1' in neighbours:\nif 'x+1' in neighbours:\nx2 = min(weights[neighbours['x-1']],weights[neighbours['x+1']]);\nelse :\nx2 = weights[neighbours['x-1']];\nelse :\nif 'x+1' in neighbours:\nx2 = weights[neighbours['x+1']];\nif 2*h**2-(x1-x2)**2&gt;=0:\nreturn (x1+x2+(2*h**2-(x1-x2)**2)**0.5)/2\nelse:\nreturn min(x1,x2)+h\nfrontier = PriorityQueue();\nweights = graph.distances;\nexplored = []\ngoals = numpy.where(graph.indicator_map==2)\ngoals_x = goals[0]\ngoals_y = goals[1]\nfor i in range(goals_x.size):\nfrontier.append([0,(goals_x[i],goals_y[i])])\nweights[(goals_x[i],goals_y[i])] = 0\nwhile frontier:\nnode = frontier.pop();\nexplored.append(node[1])\n#if node[1]==start:\n#   return weights\nneighbours = graph.get_neighbours(node[1]);\nfor neighbour in neighbours.values():\nif neighbour not in explored and graph.indicator_map[neighbour]:\nif not neighbour in frontier:\nfrontier.append([calculus_distance(neighbour,graph,weights),neighbour])\nweights[neighbour]=calculus_distance(neighbour,graph,weights)\nelif weights[neighbour] &gt; calculus_distance(neighbour,graph,weights):\nfrontier[neighbour][0]=calculus_distance(neighbour,graph,weights)\nweights[neighbour]=calculus_distance(neighbour,graph,weights)\ngraph.distances = weights\n</code></pre> <p>adjust_FM</p> <p>Ce code permet d\u2019ajuster les fronts d\u2019onde g\u00e9n\u00e9r\u00e9s par la m\u00e9thode de Fast Marching.</p> <p>Le code commence par initialiser deux listes vides, Lx_gauche et Lx_droite. Ces listes vont contenir les coordonn\u00e9es des points du front d\u2019onde qui sont \u00e0 gauche ou \u00e0 droite d\u2019un point infini ou ind\u00e9fini.</p> <p>Ensuite, le code parcourt les fronts d\u2019onde et ajoute les coordonn\u00e9es des points \u00e0 la liste Lx_gauche ou Lx_droite si ces points sont \u00e0 gauche ou \u00e0 droite d\u2019un point infini ou ind\u00e9fini. Il en fait de m\u00eame pour les coordonn\u00e9es des points du front d\u2019onde qui sont en haut ou en bas d\u2019un point infini ou ind\u00e9fini, qu\u2019il ajoute aux listes Ly_haut et Ly_bas.</p> <p>Enfin, le code remplace les valeurs des points des fronts d\u2019onde contenus dans les listes Lx_gauche, Lx_droite, Ly_haut et Ly_bas par les valeurs de leurs voisins les plus proches, en parcourant les listes et en acc\u00e9dant aux valeurs des tableaux FX et FY correspondant aux fronts d\u2019onde en question.</p> <pre><code>def adjust_FM():\nLx_gauche = []\nLx_droite = []\nfor i in range(1,n):\nfor j in range(1,len(FX[0])-1):\nu , v = FX[i][j] , FX[i][j+1]\nif u == float('inf') or u == -float('inf'):\nif v != float('inf') and v != -float('inf') and not isnan(v):\nLx_gauche.append((i,j))\nif v == float('inf') or v == -float('inf'):\nif u != float('inf') and u != -float('inf') and not isnan(u):\nLx_droite.append((i,j+1))\nfor cellule in Lx_gauche:\ni, j = cellule\nFX[i][j] = FX[i][j+1]\nfor cellule in Lx_droite:\ni, j = cellule\nFX[i][j] = FX[i][j-1]\nLy_haut = []\nLy_bas = []\nfor i in range(1,n-1):\nfor j in range(1,len(FY[0])):\nu , v = FY[i][j] , FY[i+1][j]\nif u == float('inf') or u == -float('inf'):\nif v != float('inf') and v != -float('inf') and not isnan(v):\nLy_haut.append((i,j))\nif v == float('inf') or v == -float('inf'):\nif u != float('inf') and u != -float('inf') and not isnan(u):\nLy_bas.append((i+1,j))\nfor cellule in Ly_haut:\ni, j = cellule\nFY[i][j] = FY[i+1][j]\nfor cellule in Ly_bas:\ni, j = cellule\nFY[i][j] = FY[i-1][j]\n</code></pre>"},{"location":"#myagent","title":"MyAgent","text":"<p>myAgent</p> <p>Ce code d\u00e9finit la classe <code>myAgent</code>, qui repr\u00e9sente un agent dans notre environnement de simulation. Chaque instance de cette classe contient les attributs suivants :</p> <p>position: un vecteur 2D repr\u00e9sentant la position de l\u2019agent dans l\u2019environnement.</p> <p>speed: un vecteur 2D repr\u00e9sentant la vitesse actuelle de l\u2019agent.</p> <p>D_S: un vecteur 2D repr\u00e9sentant la direction d\u00e9sir\u00e9e de l\u2019agent (c\u2019est-\u00e0-dire la direction vers laquelle il souhaite se d\u00e9placer).</p> <p>size: la taille de l\u2019agent.</p> <p>has_reached_exit: un bool\u00e9en qui indique si l\u2019agent a atteint la sortie ou non.</p> <p>near_to_exit: un bool\u00e9en qui indique si l\u2019agent est proche de la sortie ou non.</p> <p>masse: la masse de l\u2019agent.</p> <p>color: la couleur de l\u2019agent.</p> <p>La classe myAgent contient \u00e9galement plusieurs m\u00e9thodes :</p> <p>desired_direction: Cette m\u00e9thode calcule la direction d\u00e9sir\u00e9e de l\u2019agent en fonction de la position actuelle de l\u2019agent dans l\u2019environnement et de la carte de flux (contenue dans les matrices FX et FY).</p> <p>update_D_S: Cette m\u00e9thode met \u00e0 jour le vecteur D_S en appelant la m\u00e9thode desired_direction.</p> <p>update_Speed: Cette m\u00e9thode met \u00e0 jour la vitesse de l\u2019agent en fonction d\u2019un vecteur de vitesse donn\u00e9 en argument.</p> <p>reach_exit: Cette m\u00e9thode v\u00e9rifie si l\u2019agent a atteint l\u2019une des sorties de l\u2019environnement et met \u00e0 jour l\u2019attribut has_reached_exit en cons\u00e9quence.</p> <p>update_Position: Cette m\u00e9thode met \u00e0 jour la position de l\u2019agent en fonction d\u2019un vecteur de position donn\u00e9 en argument et appelle la m\u00e9thode reach_exit pour mettre \u00e0 jour l\u2019attribut has_reached_exit.</p> <pre><code>class myAgent():\ndef __init__(self, position):\nself.position = numpy.array(position)\nself.speed = (0,0)\nself.D_S = (0,0)\nself.size = 0.2\nself.has_reached_exit = False\nself.near_to_exit = False\nself.masse = 80\nself.color = 'red'\ndef desired_direction(self):\nx, y = self.position\na, b = size_scene\nn , m = int(x/h) , int((b-y)/h)\nif n &lt; 0 : n = 0\nif m &lt; 0 : m = 0\nif n &gt; len(FX[0])-1 : n = len(FX[0])-1\nif m &gt; len(FX)-1 : m = len(FX)-1\nv = numpy.array((FX[m][n], FY[m][n]))\nif norm(v)==0: return numpy.array((0,0))\nreturn v / norm(v)\ndef update_D_S(self):\nself.D_S = self.desired_direction()\ndef update_Speed(self, v):\nself.speed = (v[0],v[1])\ndef reach_exit(self):\nfor ex in exits:\nd , _ = distance_vecteur_obs(self.position , self.size, ex)\nif d &lt;= 0.2:\nself.has_reached_exit = True\nbreak\ndef update_Position(self, q):\nself.position = q\nself.reach_exit()\n</code></pre>"},{"location":"#fonctions","title":"Fonctions","text":"<p>f_motrice</p> <p>La fonction <code>f_motrice(agent)</code> calcule la force motrice qui sera appliqu\u00e9e \u00e0 l\u2019agent.</p> <p>Elle prend en entr\u00e9e l\u2019objet agent qui doit poss\u00e9der au moins un attribut D_S (vecteur unitaire repr\u00e9sentant la direction d\u00e9sir\u00e9e par l\u2019agent) et speed (vecteur vitesse de l\u2019agent).</p> <p>La force motrice est calcul\u00e9e comme suit :</p> <ul> <li> <p>Le coefficient de relaxation tau est d\u00e9fini \u00e0 0.5.</p> </li> <li> <p>La force motrice est donn\u00e9e par l\u2019expression : (2 x direction d\u00e9sir\u00e9e - vitesse courante) / tau</p> </li> <li> <p>Le r\u00e9sultat est un vecteur qui repr\u00e9sente la force motrice \u00e0 appliquer \u00e0 l\u2019agent.</p> </li> </ul> <p>La force motrice est la force qui pousse l\u2019agent \u00e0 suivre la direction d\u00e9sir\u00e9e, en prenant en compte sa vitesse courante pour \u00e9viter les changements brutaux de direction. Elle permet de mod\u00e9liser le comportement des agents qui avancent dans une direction donn\u00e9e tout en essayant de minimiser les changements de direction brusques.</p> <pre><code>#force motrice\ndef f_motrice(agent):\ntau = 0.5\nreturn (numpy.array(agent.D_S)*2 - numpy.array(agent.speed))/tau\n</code></pre> <p>dist &amp; distance_vecteur_obj &amp; distance_vecteur_obs_cir &amp; distance_vecteur_obs</p> <p>Ces fonctions sont toutes des fonctions de calcul de distance entre deux points ou un point et un obstacle.</p> <ul> <li> <p>La fonction <code>dist(p1, p2)</code> prend deux points p1 et p2 et retourne la norme de leur diff\u00e9rence. Cette norme est calcul\u00e9e en utilisant la fonction numpy.array() pour cr\u00e9er des tableaux numpy \u00e0 partir des points, puis en calculant la diff\u00e9rence entre ces tableaux \u00e0 l\u2019aide de l\u2019op\u00e9rateur - et en utilisant la fonction norm() pour calculer la norme.</p> </li> <li> <p>La fonction <code>distance_vecteur_obj(q1, q2, r1, r2)</code> prend deux points q1 et q2, ainsi que deux rayons r1 et r2 et calcule la distance entre ces deux objets. La distance est calcul\u00e9e comme la distance entre q1 et q2 moins la somme des rayons r1 et r2. La fonction renvoie \u00e9galement le vecteur normalis\u00e9 allant de q2 \u00e0 q1.</p> </li> <li> <p>La fonction <code>distance_vecteur_obs_cir(q, r, obstacle)</code> prend un point q, un rayon r et un objet circulaire obstacle (repr\u00e9sent\u00e9 par sa position et son rayon) et calcule la distance entre le point et l\u2019obstacle. La distance est calcul\u00e9e comme la distance entre le point et le centre de l\u2019obstacle, moins la somme des rayons. La fonction renvoie \u00e9galement le vecteur normalis\u00e9 allant du centre de l\u2019obstacle \u00e0 q.</p> </li> <li> <p>La fonction <code>distance_vecteur_obs(q, r, obstacle)</code> prend un point q, un rayon r et un obstacle rectangulaire obstacle (repr\u00e9sent\u00e9 par sa position, sa largeur et sa hauteur) et calcule la distance entre le point et l\u2019obstacle. La distance est calcul\u00e9e comme la distance entre q et le point de l\u2019obstacle le plus proche de q. Ce point est calcul\u00e9 en projetant q sur le rectangle et en s\u00e9lectionnant le point projet\u00e9 qui est le plus proche de q. La fonction renvoie \u00e9galement le vecteur normalis\u00e9 allant du point le plus proche de q sur l\u2019obstacle \u00e0 q.</p> </li> </ul> <pre><code>def dist(p1,p2):\nreturn norm(numpy.array(p1)-numpy.array(p2))\ndef distance_vecteur_obj(q1, q2, r1, r2):\nd = dist(q1, q2)\nn = -(numpy.array(q2) - numpy.array(q1))/d\nd = d - (r1 + r2)\nreturn d , n\ndef distance_vecteur_obs_cir(q , r, obstacle):\n[a0, b0], rayon = obstacle.position, obstacle.rayon\nx , y = q\nd = ((x-a0)**2 + (y-b0)**2)**0.5 \nn = -(numpy.array(obstacle.position) - numpy.array(q))/d\nd = d - (rayon + r)\nreturn d , n\ndef distance_vecteur_obs(q , r, obstacle):\n[a0, b0], L, l = obstacle.position, obstacle.width, obstacle.height\na1, b1 = a0 + L , b0 + l\nx , y = q\npoint = []\nif x&lt;=a0:\nif y&gt;=b1:\npoint = [a0, b1]\nelif b0&lt;y&lt;b1:\npoint = [a0, y]\nelse:\npoint = [a0, b0]\nelif a0&lt;x&lt;a1:\nif y&gt;=b1:\npoint = [x, b1]\nelif b0&lt;y&lt;b1:\npoint = [x, b1]\nelse:\npoint = [x, b0]\nelse:\nif y&gt;=b1:\npoint = [a1, b1]\nelif b0&lt;y&lt;b1:\npoint = [a1, y]\nelse:\npoint = [a1, b0]\nd = dist(point , q)\nn = (numpy.array(q) - numpy.array(point))/d\nreturn d - r , n\n</code></pre> <p>matrice_normals</p> <p>Cette fonction <code>matrice_normals(q, R)</code> calcule les vecteurs normaux pour chaque collision possible entre les agents et les obstacles dans un environnement donn\u00e9.</p> <p>La fonction prend en entr\u00e9e deux listes : q qui est la liste des positions des agents et R qui est la liste des rayons de chaque agent.</p> <p>La fonction retourne une matrice numpy, Normals, qui contient les vecteurs normaux de chaque collision, o\u00f9 chaque ligne repr\u00e9sente un vecteur normal pour un choc possible et chaque colonne repr\u00e9sente un agent (donc 2*m colonnes pour m agents). La fonction retourne \u00e9galement une liste, agents_en_chocs, qui contient les indices des agents impliqu\u00e9s dans au moins une collision.</p> <p>La fonction parcourt tous les agents et v\u00e9rifie s\u2019il y a une collision avec un autre agent ou un obstacle. Si une collision est d\u00e9tect\u00e9e, la fonction calcule le vecteur normal correspondant \u00e0 cette collision \u00e0 l\u2019aide de distance_vecteur_obj() pour une collision entre deux agents, distance_vecteur_obs() pour une collision entre un agent et un obstacle rectangulaire et distance_vecteur_obs_cir() pour une collision entre un agent et un obstacle circulaire.</p> <p>Les vecteurs normaux sont stock\u00e9s dans la matrice Normals et les indices des agents impliqu\u00e9s dans des collisions sont stock\u00e9s dans la liste agents_en_chocs.</p> <p>En fin de parcours, la fonction renvoie la matrice Normals et la liste agents_en_chocs.</p> <pre><code>def matrice_normals(q, R):\nNormals = []\nagents_en_chocs = []\nm = len(q)\n#chocs agents\nfor i in range(m):\nN = numpy.zeros(2*m)\nfor j in range(m):\nif j != i:\nd , n = distance_vecteur_obj(q[i], q[j], R[i], R[j])\nif d &lt;= 0.2:\nN[2*i], N[2*i+1], N[2*j], N[2*j+1] = n[0], n[1], -n[0], -n[1]\nif not all(v == 0 for v in N):\nNormals.append(N)\nagents_en_chocs.append(i)\n#chocs obstacle\nfor obstacle in obstacles:\nN = numpy.zeros(2*m)\nfor i in range(m):\nd , n = distance_vecteur_obs(q[i] , R[i], obstacle)\nif d &lt;= 0.2:\nN[2*i], N[2*i+1] = n[0], n[1]\nif N[2*i] != 0 or N[2*i+1] != 0:\nagents_en_chocs.append(i)\nif not all(v == 0 for v in N):\nNormals.append(N)\n#chocs obstacle circulaire\nfor obstacle in obstacles_cir:\nN = numpy.zeros(2*m)\nfor i in range(m):\nd , n = distance_vecteur_obs_cir(q[i] , R[i], obstacle)\nif d &lt;= .2:\nN[2*i], N[2*i+1] = n[0], n[1]\nif N[2*i] != 0 or N[2*i+1] != 0:\nagents_en_chocs.append(i)\nif not all(v == 0 for v in N):\nNormals.append(N)\nreturn numpy.array(Normals) , agents_en_chocs\n</code></pre> <p>detection_de_chocs</p> <p>La fonction <code>detection_de_chocs(Q, R)</code> qui prend en entr\u00e9e deux listes Q et R contenant respectivement les positions et les rayons de tous les agents et qui renvoie True si deux agents ou un agent et un obstacle se trouvent \u00e0 une distance inf\u00e9rieure \u00e0 une marge de collision marge, et False sinon.</p> <p>La fonction parcourt d\u2019abord tous les obstacles rectangulaires et circulaires stock\u00e9s dans les variables obstacles et obstacles_cir, respectivement, pour v\u00e9rifier s\u2019il y a une collision entre l\u2019agent et l\u2019un de ces obstacles en comparant les coordonn\u00e9es de l\u2019agent \u00e0 celles des coins de l\u2019obstacle et \u00e0 la distance de l\u2019agent au centre de l\u2019obstacle. Ensuite, la fonction compare la distance entre l\u2019agent courant et tous les autres agents pour v\u00e9rifier s\u2019il y a une collision entre eux.</p> <p>Si une collision est d\u00e9tect\u00e9e, la fonction retourne True, sinon elle retourne False.</p> <pre><code>def detection_de_chocs(Q, R):\nm = len(agents)\nfor i in range(m):\n[x , y], r = Q[i], R[i]\nmarge = .2\n#chocs obstacle\nfor obstacle in obstacles:\n[a0, b0], L, l = obstacle.position, obstacle.width, obstacle.height\na1, b1 = a0 + L , b0 + l\nif a0&lt;=x&lt;=a1 and b0-r-marge&lt;=y&lt;=b1+r+marge: return True\nif b0&lt;=y&lt;=b1 and a0-r-marge&lt;=x&lt;=a1+r+marge: return True\nfor obst in obstacles_cir:\n[a0, b0], rayon = obst.position, obst.rayon\nd = ((x - a0)**2 + (y - b0)**2)**0.5\nif d - (rayon+r) &lt; 2 : return True\n#chocs agents\nfor j in range(m):\nif j != i:\nif dist(Q[i], Q[j]) - (R[i]+R[j]) &lt;= marge: return True\nreturn False\n</code></pre> <p>predict_position2</p> <p>La fonction <code>predict_position2(V)</code> permet de pr\u00e9dire la position des agents \u00e0 l\u2019instant suivant en fonction de leur vitesse actuelle et leur vitesse future, ainsi que de leur position actuelle. Elle prend en entr\u00e9e une liste V de la vitesse de chaque agent (vecteur de dimension 2 pour chaque agent) \u00e0 l\u2019instant actuel.</p> <p>Le premier \u00e9l\u00e9ment de la fonction convertit la liste V en un tableau V_future de dimension p x 2 o\u00f9 p est le nombre d\u2019agents dans la simulation. Chaque ligne de V_future contient la vitesse future d\u2019un agent sous la forme d\u2019un vecteur de dimension 2.</p> <p>Le deuxi\u00e8me \u00e9l\u00e9ment de la fonction cr\u00e9e un tableau V_passe de dimension m x 2, o\u00f9 m est le nombre total d\u2019agents dans la simulation. Chaque ligne de V_passe contient la vitesse actuelle de chaque agent sous la forme d\u2019un vecteur de dimension 2.</p> <pre><code>def predict_position2(V):\np = int(len(V)/2)\nV_future =  numpy.array([ numpy.array([V[2*j], V[2*j+1]]) for j in range(p) ])\nV_passe =   numpy.array([ numpy.array(agent.speed) for agent in agents ])\nreturn [numpy.array(agent.position) + dt*(V_future[agents.index(agent)] + V_passe[agents.index(agent)])/2 for agent in agents]\n</code></pre> <p>correction_vitesses</p> <p>Cette fonction prend en entr\u00e9e la vitesse actuelle de chaque agent, la force ext\u00e9rieure appliqu\u00e9e \u00e0 chaque agent et le coefficient de restitution entre les agents. Elle calcule ensuite la nouvelle vitesse pour chaque agent en fonction des chocs d\u00e9tect\u00e9s en appelant la fonction matrice_normals qui retourne la matrice des normales pour chaque agent en collision avec un autre agent ou un obstacle.</p> <p>Dans la premi\u00e8re partie de la fonction, la fonction predict_position2 est appel\u00e9e pour pr\u00e9dire la position future des agents. Ensuite, la fonction detection_de_chocs est appel\u00e9e pour v\u00e9rifier s\u2019il y a collision entre les agents et les obstacles.</p> <p>Si une collision est d\u00e9tect\u00e9e, la fonction calcule la matrice de masse M pour chaque agent et la matrice de normales C_N pour chaque collision. Ensuite, elle calcule la matrice U en multipliant la transpos\u00e9e de C_N avec C_N. Cette matrice est utilis\u00e9e pour calculer la matrice de contrainte P.</p> <pre><code>def correction_vitesses(V, Pext, K_n):\nV, Pext = numpy.array(V), numpy.array(Pext)\np = len(agents)\nagents_en_chocs = []\nq = predict_position2(V)\nR = [agent.size for agent in agents]\nif detection_de_chocs(q, R):\n# Matrice Masse\nM = numpy.zeros((2*p, 2*p))\nfor i in range(p):\nM[2*i][2*i] = agents[i].masse\nM[2*i+1][2*i+1] = agents[i].masse\n# Matrice Normales\nC_N , agents_en_chocs = matrice_normals(q, R)\nU = dot(C_N.transpose(), C_N)\nP = matrix(numpy.array(M) + 0.5 * K_n * U , tc='d')\nq = matrix(numpy.array(dot(M - 0.5 * K_n * U , V) + dt * Pext), tc='d')\nG = matrix(numpy.array(C_N), tc='d')\nh = matrix(numpy.array(numpy.zeros(len(C_N))), tc='d')\nsolvers.options['show_progress'] = False\nreturn list(solvers.qp(P,-q,-G,h)['x']) , agents_en_chocs\nelse:\nreturn V , agents_en_chocs\n</code></pre> <p>matrice_DistancesEtNormaux &amp; matrice_DistancesEtNormaux_danger</p> <p>Ces deux fonctions g\u00e9n\u00e8rent une matrice de distances et une matrice de normales entre les agents (ou les dangers) du sc\u00e9nario.</p> <p>La fonction <code>matrice_DistancesEtNormaux(agents)</code> prend en entr\u00e9e une liste d\u2019objets agents et renvoie une matrice de distance matrice_distance et une matrice de normales matrice_normaux. Les matrices sont carr\u00e9es et de taille \u00e9gale au nombre d\u2019agents dans la liste agents. La matrice de distance matrice_distance contient les distances entre chaque paire d\u2019agents, et la matrice de normales matrice_normaux contient les normales correspondantes.</p> <p>La fonction <code>matrice_DistancesEtNormaux_danger(agents)</code> prend en entr\u00e9e une liste d\u2019objets agents et renvoie une matrice de distance matrice_distance et une matrice de normales matrice_normaux entre chaque agent de la liste et le danger Dangers[0]. La matrice de distance matrice_distance contient les distances entre chaque agent et le danger, et la matrice de normales matrice_normaux contient les normales correspondantes.</p> <pre><code>def matrice_DistancesEtNormaux(agents):\nN_ind = len(agents)\nmatrice_distance = numpy.zeros((N_ind, N_ind))\nmatrice_normaux = numpy.zeros((N_ind, N_ind,2))\nfor i in range(N_ind):\nfor j in range(N_ind):\nif i &gt; j:\nd, n = distance_vecteur_obj(agents[i].position, agents[j].position, agents[i].size, agents[j].size)\nmatrice_distance[i][j] = d\nmatrice_distance[j][i] = d\nmatrice_normaux[i][j] = n\nmatrice_normaux[j][i] = -n\nreturn matrice_distance , matrice_normaux\ndef matrice_DistancesEtNormaux_danger(agents):\nN_ind = len(agents)\nmatrice_distance = numpy.zeros(N_ind)\nmatrice_normaux = numpy.zeros((N_ind, 2))\nfor i in range(N_ind):\nd = dist(Dangers[0], agents[i].position)\nn = norm(numpy.array(Dangers[0]) - numpy.array(agents[i].position))\nmatrice_distance[i] = d\nmatrice_normaux[i] = n\nreturn matrice_distance , matrice_normaux\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<pre><code>a , b , eps = 10 , 10 , 0.2\nsize_scene = (a,b)\nobstacles = [Obstacle((0,0),a,eps), Obstacle((0,eps),eps,b-eps), Obstacle((eps,b-eps),a-eps,eps), Obstacle((a-eps, eps),eps, b-2*eps)]\nexits = [Exit((4,a-eps), 1, eps)]\nobstacles_cir = []\ndraw(exits, obstacles, obstacles_cir, size_scene, [], 0, 'gemoetrie.png', play=True)\n</code></pre> Output"},{"location":"#champs-de-directions","title":"Champs de directions","text":"<pre><code>h = .5 #pas de discritisation du FAst Marching\ngraph = GridGraph(size_scene,1/h)\ngraph.prepare_graph_for_fast_marching(obstacles, obstacles_cir, exits)\nfast_marching_method(graph, (0,0))\n</code></pre> <pre><code>d = graph.distances\nd_tr = []\nn = len(d)\nfor i in range(n):\nd_tr.append(d[n-i-1])\nFY, FX = numpy.gradient(numpy.array(d_tr))\nFX = -FX\nadjust_FM()\n</code></pre> Output"},{"location":"#simulation","title":"Simulation","text":"<pre><code>N_pop = 10\ntemps_de_sim = 1*60 #secondes\ndt = 5e-2\nN_iter = int(temps_de_sim / dt)\nagents = generate_indiv(N_pop)\ndraw(exits, obstacles, obstacles_cir, size_scene, agents, 0, 'config_init.png', play=True)\n</code></pre> Output <pre><code>K_n = 0\nR = [agent.size for agent in agents]\n!mkdir DossierImages\nfor image in os.listdir('DossierImages'):\nos.remove('DossierImages/' + image)\nfor n in tqdm(range(N_iter)):\nif len(agents)==0:break\nV_avant_correction = []\nP = []\nmatrice_distance , matrice_normaux = matrice_DistancesEtNormaux(agents)\nfor agent in agents:\nagent.update_D_S()\np_ext = f_motrice(agent)\nvi = agent.speed + dt*p_ext/agent.masse\nV_avant_correction.extend(vi)\nP.extend(p_ext)\nV_new , agents_en_chocs = correction_vitesses(V_avant_correction, P, K_n)\nq = predict_position2(V_new)\nfor agent in agents:\nk = agents.index(agent)\nagent.update_Speed([V_new[2*k] , V_new[2*k+1]])\nagent.update_Position(q[k])\nfor agent in agents:\nif agent.has_reached_exit: agents.remove(agent)\npath = 'DossierImages/simulation' + str(n) + '.jpg'\ndraw(exits, obstacles, obstacles_cir, size_scene, agents,round(n*dt, 2), savepath=path, play = False)\nprint('Simulation finished.')\nrecord_video(speed = 25)\n</code></pre> Output"}]}